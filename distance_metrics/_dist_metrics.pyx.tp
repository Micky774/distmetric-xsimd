{{py:

implementation_specific_values = [
    # Values are the following ones:
    #
    #       name_suffix, INPUT_DTYPE_t, INPUT_DTYPE
    #
    # On the first hand, an empty string is used for `name_suffix`
    # for the float64 case as to still be able to expose the original
    # float64 implementation under the same API, namely `DistanceMetric`.
    #
    # On the other hand, '32' bit is used for `name_suffix` for the float32
    # case to remove ambiguity and use `DistanceMetric32`, which is not
    # publicly exposed.
    #
    # The metric mapping is adapted accordingly to route to the correct
    # implementations.
    #
    ('', 'float64_t', 'np.float64'),
    ('32', 'float32_t', 'np.float32')
]

}}
# By Jake Vanderplas (2013) <jakevdp@cs.washington.edu>
# written for the scikit-learn project
# License: BSD

import numpy as np
cimport numpy as cnp

cnp.import_array()  # required in order to use C-API

from libc.math cimport fabs, sqrt, exp, pow, cos, sin, asin

from scipy.sparse import csr_matrix, issparse
from sklearn.utils._typedefs cimport float64_t, float32_t, int32_t, intp_t
from sklearn.utils import check_array
from sklearn.utils.fixes import parse_version, sp_base_version

cdef inline double fmax(double a, double b) noexcept nogil:
    return max(a, b)

{{for name_suffix, INPUT_DTYPE_t, INPUT_DTYPE in implementation_specific_values}}
from sklearn.metrics._dist_metrics cimport DistanceMetric{{name_suffix}}

#------------------------------------------------------------
# Manhattan Distance
#  d = sum(abs(x_i - y_i))
cdef class ManhattanDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):
    r"""Manhattan/City-block Distance metric

    .. math::
       D(x, y) = \sum_i |x_i - y_i|
    """
    def __init__(self):
        self.p = 1

    cdef inline float64_t dist(
        self,
        const {{INPUT_DTYPE_t}}* x1,
        const {{INPUT_DTYPE_t}}* x2,
        intp_t size,
    ) except -1 nogil:
        cdef float64_t d = 0
        cdef intp_t j, simd_width = 16 / sizeof({{INPUT_DTYPE_t}})
        cdef intp_t remainder = size % simd_width
        if HAS_SIMD:
            d = <float64_t> xsimd_manhattan[{{INPUT_DTYPE_t}}](x1, x2, size)
        else:
            for j in range(size):
                d += fabs(x1[j] - x2[j])
        return d

    cdef inline float64_t dist_csr(
        self,
        const {{INPUT_DTYPE_t}}* x1_data,
        const int32_t[:] x1_indices,
        const {{INPUT_DTYPE_t}}* x2_data,
        const int32_t[:] x2_indices,
        const int32_t x1_start,
        const int32_t x1_end,
        const int32_t x2_start,
        const int32_t x2_end,
        const intp_t size,
    ) except -1 nogil:

        cdef:
            intp_t ix1, ix2
            intp_t i1 = x1_start
            intp_t i2 = x2_start

            float64_t d = 0.0

        while i1 < x1_end and i2 < x2_end:
            ix1 = x1_indices[i1]
            ix2 = x2_indices[i2]

            if ix1 == ix2:
                d = d + fabs(x1_data[i1] - x2_data[i2])
                i1 = i1 + 1
                i2 = i2 + 1
            elif ix1 < ix2:
                d = d + fabs(x1_data[i1])
                i1 = i1 + 1
            else:
                d = d + fabs(x2_data[i2])
                i2 = i2 + 1

        if i1 == x1_end:
            while i2 < x2_end:
                d = d + fabs(x2_data[i2])
                i2 = i2 + 1
        else:
            while i1 < x1_end:
                d = d + fabs(x1_data[i1])
                i1 = i1 + 1

        return d
{{endfor}}
